// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`checkProjectAgainstPracticeDeclaration should be able to evaluate a practice with both a best practice and bad practices - and consider passing bad practice checks as failing the practice 1`] = `
PracticeEvaluation {
  "evaluated": Array [
    Object {
      "checked": Object {
        "badPractices": Array [
          CheckFileEvaluation {
            "check": CheckFileDeclaration {
              "check": [Function],
              "fix": null,
              "pathGlob": "package.json",
              "required": true,
              "type": "CUSTOM",
            },
            "path": "package.json",
            "practiceRef": "dates-and-times.bad-practice.moment",
            "reason": null,
            "result": "PASS",
          },
        ],
        "bestPractice": Array [
          CheckFileEvaluation {
            "check": CheckFileDeclaration {
              "check": [Function],
              "fix": null,
              "pathGlob": "package.json",
              "required": true,
              "type": "CUSTOM",
            },
            "path": "package.json",
            "practiceRef": "dates-and-times.best-practice",
            "reason": null,
            "result": "PASS",
          },
        ],
      },
      "path": "package.json",
      "result": "FAIL",
    },
  ],
  "practice": PracticeDeclaration {
    "badPractices": Array [
      CheckProjectDeclaration {
        "checks": Array [
          CheckFileDeclaration {
            "check": [Function],
            "fix": null,
            "pathGlob": "package.json",
            "required": true,
            "type": "CUSTOM",
          },
        ],
        "name": "moment",
        "readme": "using \`moment\` is a bad practice because it has a weird api that \\"mutates\\" values

for example:
\`\`\`ts
const a = moment();
const b = a.addHours(7);
expect(b.toISOString()).not.toEqual(a.toISOString()); // this will fail, since moment actually both returns \`b\` _and_ mutates \`a\`...
\`\`\`

",
      },
    ],
    "bestPractice": CheckProjectDeclaration {
      "checks": Array [
        CheckFileDeclaration {
          "check": [Function],
          "fix": null,
          "pathGlob": "package.json",
          "required": true,
          "type": "CUSTOM",
        },
      ],
      "name": "dates-and-times",
      "readme": "\`date-fns\` is a great library for manipulating dates and times in a functional, immutable, declarative pattern
",
    },
    "name": "dates-and-times",
  },
}
`;

exports[`checkProjectAgainstPracticeDeclaration should be able to evaluate a practice with only a best practice 1`] = `
PracticeEvaluation {
  "evaluated": Array [
    Object {
      "checked": Object {
        "badPractices": Array [],
        "bestPractice": Array [
          CheckFileEvaluation {
            "check": CheckFileDeclaration {
              "check": [Function],
              "fix": [Function],
              "pathGlob": ".prettierignore",
              "required": true,
              "type": "EQUALS",
            },
            "path": ".prettierignore",
            "practiceRef": "prettier.best-practice",
            "reason": "[2mexpect([22m[31mreceived[39m[2m).[22mtoEqual[2m([22m[32mexpected[39m[2m) // deep equality[22m

[32m- Expected  - 1[39m
[31m+ Received  + 1[39m

[32m- *.md[39m
[31m+ .js[39m
[2m  â†µ[22m",
            "result": "FAIL",
          },
        ],
      },
      "path": ".prettierignore",
      "result": "FAIL",
    },
    Object {
      "checked": Object {
        "badPractices": Array [],
        "bestPractice": Array [
          CheckFileEvaluation {
            "check": CheckFileDeclaration {
              "check": [Function],
              "fix": null,
              "pathGlob": "package.json",
              "required": true,
              "type": "CUSTOM",
            },
            "path": "package.json",
            "practiceRef": "prettier.best-practice",
            "reason": null,
            "result": "PASS",
          },
        ],
      },
      "path": "package.json",
      "result": "PASS",
    },
    Object {
      "checked": Object {
        "badPractices": Array [],
        "bestPractice": Array [
          CheckFileEvaluation {
            "check": CheckFileDeclaration {
              "check": [Function],
              "fix": [Function],
              "pathGlob": "prettier.config.js",
              "required": true,
              "type": "EQUALS",
            },
            "path": "prettier.config.js",
            "practiceRef": "prettier.best-practice",
            "reason": "[2mexpect([22m[31mreceived[39m[2m).[22mtoEqual[2m([22m[32mexpected[39m[2m) // deep equality[22m

[32m- Expected  - 1[39m
[31m+ Received  + 1[39m

[2m  // ref: http://json.schemastore.org/prettierrc[22m

[2m  module.exports = {[22m
[2m    trailingComma: 'all',[22m
[32m-   tabWidth: [7m2[27m,[39m
[31m+   tabWidth: [7m4[27m,[39m
[2m    singleQuote: true,[22m
[2m    printWidth: 150,[22m
[2m  };[22m
[2m  â†µ[22m",
            "result": "FAIL",
          },
        ],
      },
      "path": "prettier.config.js",
      "result": "FAIL",
    },
  ],
  "practice": PracticeDeclaration {
    "badPractices": Array [],
    "bestPractice": CheckProjectDeclaration {
      "checks": Array [
        CheckFileDeclaration {
          "check": [Function],
          "fix": [Function],
          "pathGlob": ".prettierignore",
          "required": true,
          "type": "EQUALS",
        },
        CheckFileDeclaration {
          "check": [Function],
          "fix": null,
          "pathGlob": "package.json",
          "required": true,
          "type": "CUSTOM",
        },
        CheckFileDeclaration {
          "check": [Function],
          "fix": [Function],
          "pathGlob": "prettier.config.js",
          "required": true,
          "type": "EQUALS",
        },
      ],
      "name": "prettier",
      "readme": null,
    },
    "name": "prettier",
  },
}
`;

exports[`checkProjectAgainstPracticeDeclaration should be able to evaluate a practice with wildcard glob pattern path file checks - fails best practices and passes bad practices 1`] = `
PracticeEvaluation {
  "evaluated": Array [
    Object {
      "checked": Object {
        "badPractices": Array [],
        "bestPractice": Array [
          CheckFileEvaluation {
            "check": CheckFileDeclaration {
              "check": [Function],
              "fix": null,
              "pathGlob": "src/contract/**/*.ts",
              "required": true,
              "type": "EXISTS",
            },
            "path": "src/contract/**/*.ts",
            "practiceRef": "directory-structure-src.best-practice",
            "reason": "[2mexpect([22m[31mreceived[39m[2m).[22mnot[2m.[22mtoEqual[2m([22m[32mexpected[39m[2m) // deep equality[22m

Expected: not [32mnull[39m
",
            "result": "FAIL",
          },
        ],
      },
      "path": "src/contract/**/*.ts",
      "result": "FAIL",
    },
    Object {
      "checked": Object {
        "badPractices": Array [],
        "bestPractice": Array [
          CheckFileEvaluation {
            "check": CheckFileDeclaration {
              "check": [Function],
              "fix": null,
              "pathGlob": "src/data/clients/**/*.ts",
              "required": false,
              "type": "CONTAINS",
            },
            "path": "src/data/clients/coolServiceClient.ts",
            "practiceRef": "directory-structure-src.best-practice",
            "reason": "[2mexpect([22m[31mreceived[39m[2m).[22mtoContain[2m([22m[32mexpected[39m[2m) // indexOf[22m

Expected substring: [32m\\"import { invokeLambdaFunction } from 'simple-lambda-client';[39m
[32m\\"[39m
Received string:    [31m\\"// does not have the import that the check says it wants[39m
[31m\\"[39m",
            "result": "FAIL",
          },
        ],
      },
      "path": "src/data/clients/coolServiceClient.ts",
      "result": "FAIL",
    },
    Object {
      "checked": Object {
        "badPractices": Array [],
        "bestPractice": Array [
          CheckFileEvaluation {
            "check": CheckFileDeclaration {
              "check": [Function],
              "fix": null,
              "pathGlob": "src/data/dao/**/*.ts",
              "required": false,
              "type": "EXISTS",
            },
            "path": "src/data/dao/**/*.ts",
            "practiceRef": "directory-structure-src.best-practice",
            "reason": null,
            "result": "PASS",
          },
        ],
      },
      "path": "src/data/dao/**/*.ts",
      "result": "PASS",
    },
    Object {
      "checked": Object {
        "badPractices": Array [],
        "bestPractice": Array [
          CheckFileEvaluation {
            "check": CheckFileDeclaration {
              "check": [Function],
              "fix": null,
              "pathGlob": "src/domain/constants.ts",
              "required": false,
              "type": "EXISTS",
            },
            "path": "src/domain/constants.ts",
            "practiceRef": "directory-structure-src.best-practice",
            "reason": null,
            "result": "PASS",
          },
        ],
      },
      "path": "src/domain/constants.ts",
      "result": "PASS",
    },
    Object {
      "checked": Object {
        "badPractices": Array [],
        "bestPractice": Array [
          CheckFileEvaluation {
            "check": CheckFileDeclaration {
              "check": [Function],
              "fix": null,
              "pathGlob": "src/domain/index.ts",
              "required": true,
              "type": "EXISTS",
            },
            "path": "src/domain/index.ts",
            "practiceRef": "directory-structure-src.best-practice",
            "reason": "[2mexpect([22m[31mreceived[39m[2m).[22mnot[2m.[22mtoEqual[2m([22m[32mexpected[39m[2m) // deep equality[22m

Expected: not [32mnull[39m
",
            "result": "FAIL",
          },
        ],
      },
      "path": "src/domain/index.ts",
      "result": "FAIL",
    },
    Object {
      "checked": Object {
        "badPractices": Array [],
        "bestPractice": Array [
          CheckFileEvaluation {
            "check": CheckFileDeclaration {
              "check": [Function],
              "fix": null,
              "pathGlob": "src/domain/objects/index.ts",
              "required": true,
              "type": "EXISTS",
            },
            "path": "src/domain/objects/index.ts",
            "practiceRef": "directory-structure-src.best-practice",
            "reason": "[2mexpect([22m[31mreceived[39m[2m).[22mnot[2m.[22mtoEqual[2m([22m[32mexpected[39m[2m) // deep equality[22m

Expected: not [32mnull[39m
",
            "result": "FAIL",
          },
        ],
      },
      "path": "src/domain/objects/index.ts",
      "result": "FAIL",
    },
    Object {
      "checked": Object {
        "badPractices": Array [],
        "bestPractice": Array [
          CheckFileEvaluation {
            "check": CheckFileDeclaration {
              "check": [Function],
              "fix": null,
              "pathGlob": "src/logic/**/*.ts",
              "required": true,
              "type": "EXISTS",
            },
            "path": "src/logic/**/*.ts",
            "practiceRef": "directory-structure-src.best-practice",
            "reason": "[2mexpect([22m[31mreceived[39m[2m).[22mnot[2m.[22mtoEqual[2m([22m[32mexpected[39m[2m) // deep equality[22m

Expected: not [32mnull[39m
",
            "result": "FAIL",
          },
        ],
      },
      "path": "src/logic/**/*.ts",
      "result": "FAIL",
    },
    Object {
      "checked": Object {
        "badPractices": Array [
          CheckFileEvaluation {
            "check": CheckFileDeclaration {
              "check": [Function],
              "fix": null,
              "pathGlob": "src/model/**/*",
              "required": true,
              "type": "EXISTS",
            },
            "path": "src/model/someFile.ts",
            "practiceRef": "directory-structure-src.bad-practice.model-dir",
            "reason": null,
            "result": "PASS",
          },
        ],
        "bestPractice": Array [],
      },
      "path": "src/model/someFile.ts",
      "result": "FAIL",
    },
    Object {
      "checked": Object {
        "badPractices": Array [
          CheckFileEvaluation {
            "check": CheckFileDeclaration {
              "check": [Function],
              "fix": null,
              "pathGlob": "src/services/**/*",
              "required": true,
              "type": "EXISTS",
            },
            "path": "src/services/someFile.ts",
            "practiceRef": "directory-structure-src.bad-practice.services-dir",
            "reason": null,
            "result": "PASS",
          },
        ],
        "bestPractice": Array [],
      },
      "path": "src/services/someFile.ts",
      "result": "FAIL",
    },
  ],
  "practice": PracticeDeclaration {
    "badPractices": Array [
      CheckProjectDeclaration {
        "checks": Array [
          CheckFileDeclaration {
            "check": [Function],
            "fix": null,
            "pathGlob": "src/model/**/*",
            "required": true,
            "type": "EXISTS",
          },
        ],
        "name": "model-dir",
        "readme": "we use \`domain\` directory instead of \`model\` directory
- model directory was what we originally went with, but realized \`domain\` was more explicit and better represented what we were going after
",
      },
      CheckProjectDeclaration {
        "checks": Array [
          CheckFileDeclaration {
            "check": [Function],
            "fix": null,
            "pathGlob": "src/services/**/*",
            "required": true,
            "type": "EXISTS",
          },
        ],
        "name": "services-dir",
        "readme": null,
      },
    ],
    "bestPractice": CheckProjectDeclaration {
      "checks": Array [
        CheckFileDeclaration {
          "check": [Function],
          "fix": null,
          "pathGlob": "src/contract/**/*.ts",
          "required": true,
          "type": "EXISTS",
        },
        CheckFileDeclaration {
          "check": [Function],
          "fix": null,
          "pathGlob": "src/data/clients/**/*.ts",
          "required": false,
          "type": "CONTAINS",
        },
        CheckFileDeclaration {
          "check": [Function],
          "fix": null,
          "pathGlob": "src/data/dao/**/*.ts",
          "required": false,
          "type": "EXISTS",
        },
        CheckFileDeclaration {
          "check": [Function],
          "fix": null,
          "pathGlob": "src/domain/constants.ts",
          "required": false,
          "type": "EXISTS",
        },
        CheckFileDeclaration {
          "check": [Function],
          "fix": null,
          "pathGlob": "src/domain/index.ts",
          "required": true,
          "type": "EXISTS",
        },
        CheckFileDeclaration {
          "check": [Function],
          "fix": null,
          "pathGlob": "src/domain/objects/index.ts",
          "required": true,
          "type": "EXISTS",
        },
        CheckFileDeclaration {
          "check": [Function],
          "fix": null,
          "pathGlob": "src/logic/**/*.ts",
          "required": true,
          "type": "EXISTS",
        },
      ],
      "name": "directory-structure-src",
      "readme": "layers to a project:
- contract layer
  - summary: responsible for strictly exposing the logic/domain defined in the service
  - responsibilities:
    - specifies the inputs and outputs
    - normalizes inputs on behalf of user
    - validates the inputs
    - normalizes outputs on behalf of service
- domain layer
  - summary: defines the domain which this service masters
  - responsibilities:
    - specify domain objects
    - specify constants
- logic layer
  - summary: defines the business logic that this service manages
  - responsibilities:
    - define the business logic of the domain in an organized and maintainable way
- data layer:
  - summary: defines how to persist data / leverage third party clients
  - responsibilities:
    - daos
    - clients
",
    },
    "name": "directory-structure-src",
  },
}
`;

exports[`checkProjectAgainstPracticeDeclaration should be able to evaluate a practice with wildcard glob pattern path file checks - passes with optionals 1`] = `
PracticeEvaluation {
  "evaluated": Array [
    Object {
      "checked": Object {
        "badPractices": Array [],
        "bestPractice": Array [
          CheckFileEvaluation {
            "check": CheckFileDeclaration {
              "check": [Function],
              "fix": null,
              "pathGlob": "src/contract/**/*.ts",
              "required": true,
              "type": "EXISTS",
            },
            "path": "src/contract/handlers/doSomething.ts",
            "practiceRef": "directory-structure-src.best-practice",
            "reason": null,
            "result": "PASS",
          },
        ],
      },
      "path": "src/contract/handlers/doSomething.ts",
      "result": "PASS",
    },
    Object {
      "checked": Object {
        "badPractices": Array [],
        "bestPractice": Array [
          CheckFileEvaluation {
            "check": CheckFileDeclaration {
              "check": [Function],
              "fix": null,
              "pathGlob": "src/data/clients/**/*.ts",
              "required": false,
              "type": "CONTAINS",
            },
            "path": "src/data/clients/svcAwesomeStuff.ts",
            "practiceRef": "directory-structure-src.best-practice",
            "reason": null,
            "result": "PASS",
          },
        ],
      },
      "path": "src/data/clients/svcAwesomeStuff.ts",
      "result": "PASS",
    },
    Object {
      "checked": Object {
        "badPractices": Array [],
        "bestPractice": Array [
          CheckFileEvaluation {
            "check": CheckFileDeclaration {
              "check": [Function],
              "fix": null,
              "pathGlob": "src/data/dao/**/*.ts",
              "required": false,
              "type": "EXISTS",
            },
            "path": "src/data/dao/superCoolThingDao/index.ts",
            "practiceRef": "directory-structure-src.best-practice",
            "reason": null,
            "result": "PASS",
          },
        ],
      },
      "path": "src/data/dao/superCoolThingDao/index.ts",
      "result": "PASS",
    },
    Object {
      "checked": Object {
        "badPractices": Array [],
        "bestPractice": Array [
          CheckFileEvaluation {
            "check": CheckFileDeclaration {
              "check": [Function],
              "fix": null,
              "pathGlob": "src/domain/constants.ts",
              "required": false,
              "type": "EXISTS",
            },
            "path": "src/domain/constants.ts",
            "practiceRef": "directory-structure-src.best-practice",
            "reason": null,
            "result": "PASS",
          },
        ],
      },
      "path": "src/domain/constants.ts",
      "result": "PASS",
    },
    Object {
      "checked": Object {
        "badPractices": Array [],
        "bestPractice": Array [
          CheckFileEvaluation {
            "check": CheckFileDeclaration {
              "check": [Function],
              "fix": null,
              "pathGlob": "src/domain/index.ts",
              "required": true,
              "type": "EXISTS",
            },
            "path": "src/domain/index.ts",
            "practiceRef": "directory-structure-src.best-practice",
            "reason": null,
            "result": "PASS",
          },
        ],
      },
      "path": "src/domain/index.ts",
      "result": "PASS",
    },
    Object {
      "checked": Object {
        "badPractices": Array [],
        "bestPractice": Array [
          CheckFileEvaluation {
            "check": CheckFileDeclaration {
              "check": [Function],
              "fix": null,
              "pathGlob": "src/domain/objects/index.ts",
              "required": true,
              "type": "EXISTS",
            },
            "path": "src/domain/objects/index.ts",
            "practiceRef": "directory-structure-src.best-practice",
            "reason": null,
            "result": "PASS",
          },
        ],
      },
      "path": "src/domain/objects/index.ts",
      "result": "PASS",
    },
    Object {
      "checked": Object {
        "badPractices": Array [],
        "bestPractice": Array [
          CheckFileEvaluation {
            "check": CheckFileDeclaration {
              "check": [Function],
              "fix": null,
              "pathGlob": "src/logic/**/*.ts",
              "required": true,
              "type": "EXISTS",
            },
            "path": "src/logic/doSomething.ts",
            "practiceRef": "directory-structure-src.best-practice",
            "reason": null,
            "result": "PASS",
          },
        ],
      },
      "path": "src/logic/doSomething.ts",
      "result": "PASS",
    },
    Object {
      "checked": Object {
        "badPractices": Array [
          CheckFileEvaluation {
            "check": CheckFileDeclaration {
              "check": [Function],
              "fix": null,
              "pathGlob": "src/model/**/*",
              "required": true,
              "type": "EXISTS",
            },
            "path": "src/model/**/*",
            "practiceRef": "directory-structure-src.bad-practice.model-dir",
            "reason": "[2mexpect([22m[31mreceived[39m[2m).[22mnot[2m.[22mtoEqual[2m([22m[32mexpected[39m[2m) // deep equality[22m

Expected: not [32mnull[39m
",
            "result": "FAIL",
          },
        ],
        "bestPractice": Array [],
      },
      "path": "src/model/**/*",
      "result": "PASS",
    },
    Object {
      "checked": Object {
        "badPractices": Array [
          CheckFileEvaluation {
            "check": CheckFileDeclaration {
              "check": [Function],
              "fix": null,
              "pathGlob": "src/services/**/*",
              "required": true,
              "type": "EXISTS",
            },
            "path": "src/services/**/*",
            "practiceRef": "directory-structure-src.bad-practice.services-dir",
            "reason": "[2mexpect([22m[31mreceived[39m[2m).[22mnot[2m.[22mtoEqual[2m([22m[32mexpected[39m[2m) // deep equality[22m

Expected: not [32mnull[39m
",
            "result": "FAIL",
          },
        ],
        "bestPractice": Array [],
      },
      "path": "src/services/**/*",
      "result": "PASS",
    },
  ],
  "practice": PracticeDeclaration {
    "badPractices": Array [
      CheckProjectDeclaration {
        "checks": Array [
          CheckFileDeclaration {
            "check": [Function],
            "fix": null,
            "pathGlob": "src/model/**/*",
            "required": true,
            "type": "EXISTS",
          },
        ],
        "name": "model-dir",
        "readme": "we use \`domain\` directory instead of \`model\` directory
- model directory was what we originally went with, but realized \`domain\` was more explicit and better represented what we were going after
",
      },
      CheckProjectDeclaration {
        "checks": Array [
          CheckFileDeclaration {
            "check": [Function],
            "fix": null,
            "pathGlob": "src/services/**/*",
            "required": true,
            "type": "EXISTS",
          },
        ],
        "name": "services-dir",
        "readme": null,
      },
    ],
    "bestPractice": CheckProjectDeclaration {
      "checks": Array [
        CheckFileDeclaration {
          "check": [Function],
          "fix": null,
          "pathGlob": "src/contract/**/*.ts",
          "required": true,
          "type": "EXISTS",
        },
        CheckFileDeclaration {
          "check": [Function],
          "fix": null,
          "pathGlob": "src/data/clients/**/*.ts",
          "required": false,
          "type": "CONTAINS",
        },
        CheckFileDeclaration {
          "check": [Function],
          "fix": null,
          "pathGlob": "src/data/dao/**/*.ts",
          "required": false,
          "type": "EXISTS",
        },
        CheckFileDeclaration {
          "check": [Function],
          "fix": null,
          "pathGlob": "src/domain/constants.ts",
          "required": false,
          "type": "EXISTS",
        },
        CheckFileDeclaration {
          "check": [Function],
          "fix": null,
          "pathGlob": "src/domain/index.ts",
          "required": true,
          "type": "EXISTS",
        },
        CheckFileDeclaration {
          "check": [Function],
          "fix": null,
          "pathGlob": "src/domain/objects/index.ts",
          "required": true,
          "type": "EXISTS",
        },
        CheckFileDeclaration {
          "check": [Function],
          "fix": null,
          "pathGlob": "src/logic/**/*.ts",
          "required": true,
          "type": "EXISTS",
        },
      ],
      "name": "directory-structure-src",
      "readme": "layers to a project:
- contract layer
  - summary: responsible for strictly exposing the logic/domain defined in the service
  - responsibilities:
    - specifies the inputs and outputs
    - normalizes inputs on behalf of user
    - validates the inputs
    - normalizes outputs on behalf of service
- domain layer
  - summary: defines the domain which this service masters
  - responsibilities:
    - specify domain objects
    - specify constants
- logic layer
  - summary: defines the business logic that this service manages
  - responsibilities:
    - define the business logic of the domain in an organized and maintainable way
- data layer:
  - summary: defines how to persist data / leverage third party clients
  - responsibilities:
    - daos
    - clients
",
    },
    "name": "directory-structure-src",
  },
}
`;

exports[`checkProjectAgainstPracticeDeclaration should be able to evaluate a practice with wildcard glob pattern path file checks - passes without optionals 1`] = `
PracticeEvaluation {
  "evaluated": Array [
    Object {
      "checked": Object {
        "badPractices": Array [],
        "bestPractice": Array [
          CheckFileEvaluation {
            "check": CheckFileDeclaration {
              "check": [Function],
              "fix": null,
              "pathGlob": "src/contract/**/*.ts",
              "required": true,
              "type": "EXISTS",
            },
            "path": "src/contract/handlers/doSomething.ts",
            "practiceRef": "directory-structure-src.best-practice",
            "reason": null,
            "result": "PASS",
          },
        ],
      },
      "path": "src/contract/handlers/doSomething.ts",
      "result": "PASS",
    },
    Object {
      "checked": Object {
        "badPractices": Array [],
        "bestPractice": Array [
          CheckFileEvaluation {
            "check": CheckFileDeclaration {
              "check": [Function],
              "fix": null,
              "pathGlob": "src/data/clients/**/*.ts",
              "required": false,
              "type": "CONTAINS",
            },
            "path": "src/data/clients/**/*.ts",
            "practiceRef": "directory-structure-src.best-practice",
            "reason": null,
            "result": "PASS",
          },
        ],
      },
      "path": "src/data/clients/**/*.ts",
      "result": "PASS",
    },
    Object {
      "checked": Object {
        "badPractices": Array [],
        "bestPractice": Array [
          CheckFileEvaluation {
            "check": CheckFileDeclaration {
              "check": [Function],
              "fix": null,
              "pathGlob": "src/data/dao/**/*.ts",
              "required": false,
              "type": "EXISTS",
            },
            "path": "src/data/dao/**/*.ts",
            "practiceRef": "directory-structure-src.best-practice",
            "reason": null,
            "result": "PASS",
          },
        ],
      },
      "path": "src/data/dao/**/*.ts",
      "result": "PASS",
    },
    Object {
      "checked": Object {
        "badPractices": Array [],
        "bestPractice": Array [
          CheckFileEvaluation {
            "check": CheckFileDeclaration {
              "check": [Function],
              "fix": null,
              "pathGlob": "src/domain/constants.ts",
              "required": false,
              "type": "EXISTS",
            },
            "path": "src/domain/constants.ts",
            "practiceRef": "directory-structure-src.best-practice",
            "reason": null,
            "result": "PASS",
          },
        ],
      },
      "path": "src/domain/constants.ts",
      "result": "PASS",
    },
    Object {
      "checked": Object {
        "badPractices": Array [],
        "bestPractice": Array [
          CheckFileEvaluation {
            "check": CheckFileDeclaration {
              "check": [Function],
              "fix": null,
              "pathGlob": "src/domain/index.ts",
              "required": true,
              "type": "EXISTS",
            },
            "path": "src/domain/index.ts",
            "practiceRef": "directory-structure-src.best-practice",
            "reason": null,
            "result": "PASS",
          },
        ],
      },
      "path": "src/domain/index.ts",
      "result": "PASS",
    },
    Object {
      "checked": Object {
        "badPractices": Array [],
        "bestPractice": Array [
          CheckFileEvaluation {
            "check": CheckFileDeclaration {
              "check": [Function],
              "fix": null,
              "pathGlob": "src/domain/objects/index.ts",
              "required": true,
              "type": "EXISTS",
            },
            "path": "src/domain/objects/index.ts",
            "practiceRef": "directory-structure-src.best-practice",
            "reason": null,
            "result": "PASS",
          },
        ],
      },
      "path": "src/domain/objects/index.ts",
      "result": "PASS",
    },
    Object {
      "checked": Object {
        "badPractices": Array [],
        "bestPractice": Array [
          CheckFileEvaluation {
            "check": CheckFileDeclaration {
              "check": [Function],
              "fix": null,
              "pathGlob": "src/logic/**/*.ts",
              "required": true,
              "type": "EXISTS",
            },
            "path": "src/logic/doSomething.ts",
            "practiceRef": "directory-structure-src.best-practice",
            "reason": null,
            "result": "PASS",
          },
        ],
      },
      "path": "src/logic/doSomething.ts",
      "result": "PASS",
    },
    Object {
      "checked": Object {
        "badPractices": Array [
          CheckFileEvaluation {
            "check": CheckFileDeclaration {
              "check": [Function],
              "fix": null,
              "pathGlob": "src/model/**/*",
              "required": true,
              "type": "EXISTS",
            },
            "path": "src/model/**/*",
            "practiceRef": "directory-structure-src.bad-practice.model-dir",
            "reason": "[2mexpect([22m[31mreceived[39m[2m).[22mnot[2m.[22mtoEqual[2m([22m[32mexpected[39m[2m) // deep equality[22m

Expected: not [32mnull[39m
",
            "result": "FAIL",
          },
        ],
        "bestPractice": Array [],
      },
      "path": "src/model/**/*",
      "result": "PASS",
    },
    Object {
      "checked": Object {
        "badPractices": Array [
          CheckFileEvaluation {
            "check": CheckFileDeclaration {
              "check": [Function],
              "fix": null,
              "pathGlob": "src/services/**/*",
              "required": true,
              "type": "EXISTS",
            },
            "path": "src/services/**/*",
            "practiceRef": "directory-structure-src.bad-practice.services-dir",
            "reason": "[2mexpect([22m[31mreceived[39m[2m).[22mnot[2m.[22mtoEqual[2m([22m[32mexpected[39m[2m) // deep equality[22m

Expected: not [32mnull[39m
",
            "result": "FAIL",
          },
        ],
        "bestPractice": Array [],
      },
      "path": "src/services/**/*",
      "result": "PASS",
    },
  ],
  "practice": PracticeDeclaration {
    "badPractices": Array [
      CheckProjectDeclaration {
        "checks": Array [
          CheckFileDeclaration {
            "check": [Function],
            "fix": null,
            "pathGlob": "src/model/**/*",
            "required": true,
            "type": "EXISTS",
          },
        ],
        "name": "model-dir",
        "readme": "we use \`domain\` directory instead of \`model\` directory
- model directory was what we originally went with, but realized \`domain\` was more explicit and better represented what we were going after
",
      },
      CheckProjectDeclaration {
        "checks": Array [
          CheckFileDeclaration {
            "check": [Function],
            "fix": null,
            "pathGlob": "src/services/**/*",
            "required": true,
            "type": "EXISTS",
          },
        ],
        "name": "services-dir",
        "readme": null,
      },
    ],
    "bestPractice": CheckProjectDeclaration {
      "checks": Array [
        CheckFileDeclaration {
          "check": [Function],
          "fix": null,
          "pathGlob": "src/contract/**/*.ts",
          "required": true,
          "type": "EXISTS",
        },
        CheckFileDeclaration {
          "check": [Function],
          "fix": null,
          "pathGlob": "src/data/clients/**/*.ts",
          "required": false,
          "type": "CONTAINS",
        },
        CheckFileDeclaration {
          "check": [Function],
          "fix": null,
          "pathGlob": "src/data/dao/**/*.ts",
          "required": false,
          "type": "EXISTS",
        },
        CheckFileDeclaration {
          "check": [Function],
          "fix": null,
          "pathGlob": "src/domain/constants.ts",
          "required": false,
          "type": "EXISTS",
        },
        CheckFileDeclaration {
          "check": [Function],
          "fix": null,
          "pathGlob": "src/domain/index.ts",
          "required": true,
          "type": "EXISTS",
        },
        CheckFileDeclaration {
          "check": [Function],
          "fix": null,
          "pathGlob": "src/domain/objects/index.ts",
          "required": true,
          "type": "EXISTS",
        },
        CheckFileDeclaration {
          "check": [Function],
          "fix": null,
          "pathGlob": "src/logic/**/*.ts",
          "required": true,
          "type": "EXISTS",
        },
      ],
      "name": "directory-structure-src",
      "readme": "layers to a project:
- contract layer
  - summary: responsible for strictly exposing the logic/domain defined in the service
  - responsibilities:
    - specifies the inputs and outputs
    - normalizes inputs on behalf of user
    - validates the inputs
    - normalizes outputs on behalf of service
- domain layer
  - summary: defines the domain which this service masters
  - responsibilities:
    - specify domain objects
    - specify constants
- logic layer
  - summary: defines the business logic that this service manages
  - responsibilities:
    - define the business logic of the domain in an organized and maintainable way
- data layer:
  - summary: defines how to persist data / leverage third party clients
  - responsibilities:
    - daos
    - clients
",
    },
    "name": "directory-structure-src",
  },
}
`;
