# Execution: Replace oclif with commander

## Context

oclif has a history of deprecating itself and adds many transitive dependencies. The goal was to replace it with `commander`, following the pattern established in [ehmpathy/declastruct](https://github.com/ehmpathy/declastruct).

## Reference Pattern (declastruct)

The declastruct CLI pattern consists of:
- `bin/run` - Entry point using `#!/usr/bin/env tsx` shebang, imports `invoke()` from dist
- `src/contract/cli/invoke.ts` - Commander setup with all commands defined
- `src/contract/cli/*.ts` - Individual command execution functions

## Steps Executed

### 1. Create the CLI invoke entry point

Created `src/contract/cli/invoke.ts`:
```typescript
import { Command } from 'commander';
import { readFileSync } from 'fs';
import { join } from 'path';

const getVersion = (): string => {
  const packageJson = JSON.parse(
    readFileSync(join(__dirname, '../../../package.json'), 'utf-8'),
  );
  return packageJson.version;
};

export const invoke = async ({ args }: { args: string[] }): Promise<void> => {
  const program = new Command();

  program
    .name('declapract')
    .description('...')
    .version(getVersion());

  program
    .command('plan')
    .description('...')
    .option('-c, --config <path>', '...', 'declapract.use.yml')
    .option('-p, --practice <name>', '...')
    .option('-f, --file <path>', '...')
    .action(async (options: { config: string; practice?: string; file?: string }) => {
      try {
        await executePlan(options);
      } catch (error) {
        console.error(error);
        process.exit(1);
      }
    });

  // ... similar for apply, validate, compile

  await program.parseAsync(args, { from: 'user' });
};
```

### 2. Create SDK functions for programmatic usage

Created individual files in `src/contract/sdk/`:

**`src/contract/sdk/plan.ts`**:
```typescript
import { plan } from '../../logic/commands/plan';

export const executePlan = async (options: {
  config: string;
  practice?: string;
  file?: string;
}): Promise<void> => {
  const configPath =
    options.config.slice(0, 1) === '/'
      ? options.config
      : `${process.cwd()}/${options.config}`;

  await plan({
    usePracticesConfigPath: configPath,
    filter:
      options.practice || options.file
        ? {
            practiceNames: options.practice ? [options.practice] : undefined,
            filePaths: options.file ? [options.file] : undefined,
          }
        : undefined,
  });
};
```

Similar pattern for `apply.ts`, `validate.ts`, `compile.ts`.

### 3. Update the bin/run entry point

Changed from oclif to tsx + commander:

**Before:**
```javascript
#!/usr/bin/env node
require('ts-node').register();
require('@oclif/core')
  .run()
  .then(require('@oclif/core/flush'))
  .catch(require('@oclif/core/handle'));
```

**After:**
```typescript
#!/usr/bin/env tsx
import { invoke } from '../dist/contract/cli/invoke';
void invoke({ args: process.argv.slice(2) });
```

### 4. Update package.json

**Removed dependencies:**
- `@oclif/core`
- `@oclif/plugin-help`
- `oclif`

**Removed devDependencies:**
- `@oclif/dev-cli`

**Added dependencies:**
- `commander` (12.1.0)

**Removed configuration block:**
```json
"oclif": {
  "commands": "./dist/contract/commands",
  "bin": "declapract",
  "plugins": ["@oclif/plugin-help"]
}
```

**Updated script:**
```json
"generate:cli-readme": "echo 'no oclif readme generation'"
```

### 5. Export SDK functions from package

Updated `src/contract/index.ts`:
```typescript
// SDK exports for programmatic usage
export { executeApply } from './sdk/apply';
export { executeCompile } from './sdk/compile';
export { executePlan } from './sdk/plan';
export { executeValidate } from './sdk/validate';
```

### 6. Cleanup

Removed:
- `src/contract/commands/` directory (old oclif commands)
- `bin/run.cmd` (Windows batch file for oclif)

### 7. Create unit tests

Created tests in `src/contract/sdk/*.test.ts` mirroring the old `src/contract/commands/*.test.ts` tests:

```typescript
import { plan } from '../../logic/commands/plan';
import { executePlan } from './plan';

jest.mock('../../logic/commands/plan');
const planMock = plan as jest.Mock;

describe('executePlan', () => {
  it('should call the plan command logic', async () => {
    await executePlan({ config: '/some/path/to/use' });
    expect(planMock).toHaveBeenCalledTimes(1);
    expect(planMock).toHaveBeenCalledWith({
      usePracticesConfigPath: '/some/path/to/use',
    });
  });
});
```

## Result

- Removed 50 packages from node_modules
- CLI works identically: `./bin/run plan --help`, `./bin/run apply -c config.yml`, etc.
- SDK functions available for programmatic use: `import { executePlan } from 'declapract'`
- All unit and integration tests pass

## Key Patterns to Follow

1. **Use `Command` from commander, not `program` singleton** - Create new instance for testability
2. **Inline option types in action handlers** - No separate interface definitions needed
3. **Import SDK functions directly in invoke.ts** - No unnecessary index.ts barrel files
4. **Use tsx shebang** - `#!/usr/bin/env tsx` enables TypeScript execution without ts-node registration
5. **Path resolution** - Convert relative paths to absolute using `process.cwd()`
6. **Error handling** - Wrap action handlers in try/catch, log error and `process.exit(1)`
