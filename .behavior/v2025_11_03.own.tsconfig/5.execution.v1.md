# Execution: Remove dependency on host's tsconfig

## Context

The CLI previously depended on the host project's `tsconfig.json` because it used `ts-node` to register TypeScript at runtime. This caused issues when:
- The host project's tsconfig was being upgraded/modified
- Running `declapract apply` during a tsconfig migration would fail

## Problem

**Before (`bin/run`):**
```javascript
#!/usr/bin/env node
require('ts-node').register(); // <-- depends on host's tsconfig.json
require('@oclif/core')
  .run()
  .then(require('@oclif/core/flush'))
  .catch(require('@oclif/core/handle'));
```

`ts-node.register()` looks for and uses the host project's `tsconfig.json` for TypeScript compilation settings.

## Solution

**After (`bin/run`):**
```typescript
#!/usr/bin/env tsx
import { invoke } from '../dist/contract/cli/invoke';
void invoke({ args: process.argv.slice(2) });
```

Key changes:
1. **`tsx` instead of `ts-node`** - tsx uses esbuild under the hood, which executes TypeScript without type-checking and without requiring a tsconfig
2. **Import from `dist/`** - The CLI imports pre-compiled JavaScript from the package's dist directory, so no TypeScript compilation happens at runtime in the host project

## Why tsx works without tsconfig

`tsx` (via esbuild):
- Transpiles TypeScript to JavaScript on-the-fly
- Does not perform type-checking
- Uses sensible defaults that work for execution
- Does not read or require `tsconfig.json`

## Result

- CLI executes independently of host project's TypeScript configuration
- Safe to run `declapract apply` while modifying host's tsconfig
- Faster startup since no type-checking occurs
- Already had `tsx` as a devDependency, now used in production bin

## Note

This was fulfilled as part of the oclif â†’ commander migration (see `v2025_11_03.no.oclif/5.execution.v1.md`).
