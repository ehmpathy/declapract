# blueprint: depver-linked-nofix

## summary

when `@declapract{check.minVersion('x.y.z')}` expressions are evaluated, linked dependency versions (e.g., `link:.`, `link:../path`) should automatically pass the check and never be "fixed" to a semver string.

linked versions indicate the repo IS the package and always uses the latest local code, so by definition they satisfy any minimum version requirement.

---

## domain analysis

### current behavior

1. **check phase** (`checkDoesFoundValuePassesMinVersionCheck`):
   - uses `defineMinPackageVersionRegex(minVersion)` to create semver-matched regex
   - tests found value against regex
   - `link:.` does NOT match semver regex → check FAILS

2. **fix phase** (`deepReplaceOrAddCurrentKeyValuesWithDesiredKeyValues`):
   - when check fails, replaces current value with `minVersion` string
   - `link:.` gets replaced with e.g., `4.0.0` → WRONG behavior

### desired behavior

1. **check phase**:
   - if found value is a linked version → return `true` (passes)
   - linked versions satisfy ANY minimum version by definition

2. **fix phase**:
   - if current value is a linked version → preserve it, don't replace
   - linked versions should never be touched

### linked version patterns

recognize these npm/yarn/pnpm link specifiers:
- `link:.` — current directory (repo IS the package)
- `link:..` — parent directory
- `link:../path/to/package` — relative path
- `link:/absolute/path` — absolute path (rare but valid)

pattern: `/^link:/` prefix

---

## implementation plan

### 1. add linked version detection utility

**file**: `src/domain.operations/declaration/readPracticeDeclarations/readPracticeDeclaration/getFileCheckDeclaration/checkExpressions/check.minVersion.ts`

add new function:

```ts
/**
 * .what = checks if a version string is a linked dependency version
 * .why = linked versions (link:.) indicate the repo IS the package,
 *        so they satisfy any minVersion check by definition
 */
export const isLinkedDependencyVersion = (value: unknown): boolean => {
  if (typeof value !== 'string') return false;
  return value.startsWith('link:');
};
```

### 2. update check logic

**file**: `src/domain.operations/declaration/readPracticeDeclarations/readPracticeDeclaration/getFileCheckDeclaration/checkExpressions/check.minVersion.ts`

modify `checkDoesFoundValuePassesMinVersionCheck`:

```ts
export const checkDoesFoundValuePassesMinVersionCheck = ({
  foundValue,
  minVersion,
}: {
  foundValue: any;
  minVersion: string;
}): boolean => {
  // linked versions always pass - they use the latest local code by definition
  if (isLinkedDependencyVersion(foundValue)) return true;

  // define the regex to check against
  const minVersionRegexp = defineMinPackageVersionRegex(minVersion);

  // if foundValue does not match it, return the error message
  if (typeof foundValue !== 'string') return false;
  return minVersionRegexp.test(foundValue);
};
```

### 3. update fix logic

**file**: `src/domain.operations/declaration/readPracticeDeclarations/readPracticeDeclaration/getFileCheckDeclaration/fixMethods/fixContainsJSONByReplacingAndAddingKeyValues.ts`

modify `deepReplaceOrAddCurrentKeyValuesWithDesiredKeyValues` to preserve linked versions:

```ts
import {
  checkDoesFoundValuePassesMinVersionCheck,
  getMinVersionFromCheckMinVersionExpression,
  isCheckMinVersionExpression,
  isLinkedDependencyVersion,
} from '@src/domain.operations/declaration/readPracticeDeclarations/readPracticeDeclaration/getFileCheckDeclaration/checkExpressions/check.minVersion';

// ... in deepReplaceOrAddCurrentKeyValuesWithDesiredKeyValues:

if (isCheckMinVersionExpression(desiredValue)) {
  // preserve linked versions - they satisfy any minVersion by definition
  if (isLinkedDependencyVersion(currentValue)) return currentValue;

  const minVersion = getMinVersionFromCheckMinVersionExpression(desiredValue);
  if (!minVersion)
    throw new UnexpectedCodePathError(
      "checked that its a min version expression but couldn't extract a min version",
    );
  const passesMinVersion = checkDoesFoundValuePassesMinVersionCheck({
    foundValue: currentValue,
    minVersion,
  });
  if (passesMinVersion) return currentValue;
  return minVersion;
}
```

---

## test plan

### unit tests for `isLinkedDependencyVersion`

**file**: `src/domain.operations/declaration/readPracticeDeclarations/readPracticeDeclaration/getFileCheckDeclaration/checkExpressions/check.minVersion.test.ts` (new file)

```ts
import {
  isLinkedDependencyVersion,
  checkDoesFoundValuePassesMinVersionCheck,
} from './check.minVersion';

describe('isLinkedDependencyVersion', () => {
  const TEST_CASES = [
    { input: 'link:.', expected: true, description: 'link:. (current dir)' },
    { input: 'link:..', expected: true, description: 'link:.. (parent dir)' },
    { input: 'link:../adjacent', expected: true, description: 'link:../adjacent (relative path)' },
    { input: 'link:/absolute/path', expected: true, description: 'link:/absolute/path' },
    { input: '1.2.3', expected: false, description: 'semver version' },
    { input: '^1.2.3', expected: false, description: 'semver range' },
    { input: 'latest', expected: false, description: 'dist-tag' },
    { input: 'file:../path', expected: false, description: 'file: protocol (not link:)' },
    { input: '', expected: false, description: 'empty string' },
    { input: null, expected: false, description: 'null' },
    { input: undefined, expected: false, description: 'undefined' },
    { input: 123, expected: false, description: 'number' },
  ];

  TEST_CASES.forEach(({ input, expected, description }) => {
    it(`should return ${expected} for ${description}`, () => {
      expect(isLinkedDependencyVersion(input)).toEqual(expected);
    });
  });
});

describe('checkDoesFoundValuePassesMinVersionCheck', () => {
  describe('linked versions', () => {
    it('should pass for link:. regardless of minVersion', () => {
      expect(
        checkDoesFoundValuePassesMinVersionCheck({
          foundValue: 'link:.',
          minVersion: '99.99.99',
        }),
      ).toEqual(true);
    });

    it('should pass for link:../path regardless of minVersion', () => {
      expect(
        checkDoesFoundValuePassesMinVersionCheck({
          foundValue: 'link:../some-package',
          minVersion: '10.0.0',
        }),
      ).toEqual(true);
    });
  });

  describe('semver versions', () => {
    it('should pass when version >= minVersion', () => {
      expect(
        checkDoesFoundValuePassesMinVersionCheck({
          foundValue: '4.5.0',
          minVersion: '4.0.0',
        }),
      ).toEqual(true);
    });

    it('should fail when version < minVersion', () => {
      expect(
        checkDoesFoundValuePassesMinVersionCheck({
          foundValue: '3.9.9',
          minVersion: '4.0.0',
        }),
      ).toEqual(false);
    });
  });
});
```

### unit tests for fix logic

**file**: `src/domain.operations/declaration/readPracticeDeclarations/readPracticeDeclaration/getFileCheckDeclaration/fixMethods/fixContainsJSONByReplacingAndAddingKeyValues.test.ts`

add new test cases:

```ts
describe('check.minVersion with linked versions', () => {
  it('should NOT replace link:. with minVersion', async () => {
    const foundContents = JSON.stringify({
      dependencies: {
        'my-package': 'link:.',
      },
    });
    const declaredContents = JSON.stringify({
      dependencies: {
        'my-package': "@declapract{check.minVersion('2.0.0')}",
      },
    });

    const { contents: fixedContents } =
      await fixContainsJSONByReplacingAndAddingKeyValues(foundContents, {
        declaredFileContents: declaredContents,
        projectVariables: {},
      } as FileCheckContext);

    const fixedJSON = JSON.parse(fixedContents!);
    expect(fixedJSON.dependencies['my-package']).toEqual('link:.');
  });

  it('should NOT replace link:../path with minVersion', async () => {
    const foundContents = JSON.stringify({
      devDependencies: {
        'adjacent-package': 'link:../adjacent-package',
      },
    });
    const declaredContents = JSON.stringify({
      devDependencies: {
        'adjacent-package': "@declapract{check.minVersion('1.0.0')}",
      },
    });

    const { contents: fixedContents } =
      await fixContainsJSONByReplacingAndAddingKeyValues(foundContents, {
        declaredFileContents: declaredContents,
        projectVariables: {},
      } as FileCheckContext);

    const fixedJSON = JSON.parse(fixedContents!);
    expect(fixedJSON.devDependencies['adjacent-package']).toEqual(
      'link:../adjacent-package',
    );
  });

  it('should still replace non-linked versions that fail minVersion check', async () => {
    const foundContents = JSON.stringify({
      dependencies: {
        'some-package': '1.0.0',
      },
    });
    const declaredContents = JSON.stringify({
      dependencies: {
        'some-package': "@declapract{check.minVersion('2.0.0')}",
      },
    });

    const { contents: fixedContents } =
      await fixContainsJSONByReplacingAndAddingKeyValues(foundContents, {
        declaredFileContents: declaredContents,
        projectVariables: {},
      } as FileCheckContext);

    const fixedJSON = JSON.parse(fixedContents!);
    expect(fixedJSON.dependencies['some-package']).toEqual('2.0.0');
  });
});
```

### unit tests for check logic

**file**: `src/domain.operations/declaration/readPracticeDeclarations/readPracticeDeclaration/getFileCheckDeclaration/checkMethods/composableActions/checkContainsJSON.test.ts`

add new test cases:

```ts
describe('linked versions with check.minVersion', () => {
  it('should pass when found version is link:. and declared is minVersion check', () => {
    const result = checkContainsJSON({
      declaredContents: JSON.stringify({
        dependencies: {
          'my-package': "@declapract{check.minVersion('5.0.0')}",
        },
      }),
      foundContents: JSON.stringify({
        dependencies: {
          'my-package': 'link:.',
        },
      }),
    });
    expect(result).not.toBeDefined();
  });

  it('should pass when found version is link:../path and declared is minVersion check', () => {
    const result = checkContainsJSON({
      declaredContents: JSON.stringify({
        devDependencies: {
          'adjacent-lib': "@declapract{check.minVersion('1.0.0')}",
        },
      }),
      foundContents: JSON.stringify({
        devDependencies: {
          'adjacent-lib': 'link:../adjacent-lib',
        },
      }),
    });
    expect(result).not.toBeDefined();
  });
});
```

### integration tests

**file**: `src/domain.operations/usage/plan/apply/fixFile.integration.test.ts`

add integration test that verifies end-to-end behavior:

```ts
describe('linked dependency versions', () => {
  it('should not attempt to fix link:. versions when minVersion is declared', async () => {
    // setup: create a package.json with link:. dependency
    // and a practice that declares minVersion for that dependency
    // verify: the fix operation preserves link:. unchanged
  });
});
```

### acceptance tests

**file**: `src/contract/commands/apply.acceptance.test.ts` (if exists, or create)

```ts
describe('apply command with linked dependencies', () => {
  given('[case1] project with link:. dependency', () => {
    // setup: real project with package.json that has link:.
    // practice: declares minVersion for the linked package

    when('[t0] apply is run', () => {
      then('link:. should be preserved unchanged', async () => {
        // verify package.json still has link:.
      });

      then('no fix plan should be generated for the linked dependency', async () => {
        // verify the plan shows no changes for that key
      });
    });
  });
});
```

---

## files to modify

| file | change |
|------|--------|
| `src/domain.operations/declaration/.../check.minVersion.ts` | add `isLinkedDependencyVersion`, update `checkDoesFoundValuePassesMinVersionCheck` |
| `src/domain.operations/declaration/.../fixContainsJSONByReplacingAndAddingKeyValues.ts` | import and use `isLinkedDependencyVersion` to preserve linked versions |

## files to create

| file | purpose |
|------|---------|
| `src/domain.operations/declaration/.../check.minVersion.test.ts` | unit tests for linked version detection |

## files to update (tests)

| file | change |
|------|--------|
| `src/domain.operations/declaration/.../checkContainsJSON.test.ts` | add linked version test cases |
| `src/domain.operations/declaration/.../fixContainsJSONByReplacingAndAddingKeyValues.test.ts` | add linked version test cases |

---

## edge cases

1. **`link:` with absolute path** — should also pass (`link:/home/user/pkg`)
2. **mixed dependencies** — some linked, some semver — each evaluated independently
3. **nested linked versions** — e.g., in `peerDependencies`, `optionalDependencies`
4. **`file:` protocol** — NOT the same as `link:`, should NOT auto-pass (file: copies, link: symlinks)

---

## rollout

1. implement `isLinkedDependencyVersion` utility
2. add unit tests for the utility
3. update `checkDoesFoundValuePassesMinVersionCheck` to use the utility
4. add unit tests for check behavior
5. update fix logic to preserve linked versions
6. add unit tests for fix behavior
7. run full test suite
8. manual verification with a repo that has `link:.` dependencies
